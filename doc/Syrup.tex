\documentclass{article}
\usepackage{a4wide}
\usepackage{alltt}

\begin{document}
\title{Syrup\\ {\large a programming language for digital circuits}}
\author{Conor McBride}
\maketitle


\section{Introduction}

\textbf{Syrup} is a small domain-specific programming language designed
for digital circuits. It is intended mainly for use in the teaching and
assessment of the digital logic components of CS106 \emph{Computer Systems
  and Organisation} and CS111 \emph{Computational Thinking} at the University
of Strathclyde. By moving from circuit diagrams on paper to circuits
programmed in Syrup, we hopefully facilitate improved automation of
feedback.

In previous years, we used an ascii-art circuit language called CVI
(the Circuit Validation Interpreter, and also 106, of course). Circuits
looked like diagrams, but drawing ascii art in an ordinary text editor
is tricky, even if you have picked up the knack. It is time to move on.


\section{Overview}

Circuits are made from components. Components are made from other
components. Syrup is a language for defining new components from existing
components.

A component should have
\begin{itemize}
\item a \textbf{declaration}, which gives it a unique name and specifies its
  external connectivity
\item a \textbf{definition}, which explains how it is constructed.
\end{itemize}

For example, let us build a `not' gate from a `nand' gate.

\begin{alltt}
not(<Bit>) -> <Bit>
not(X) = Y where
  Y = nand(X,X)
\end{alltt}

This renders in textual form the diagram (which was a nuisance to typeset).
\[\begin{array}{lccccc}
    \mathsf{not} && & \hspace*{0.12in}|X & & \vspace*{-0.03in}\\
               && & | & & \vspace*{-0.03in}\\
    \cline{3-5}
       &        & \multicolumn{3}{|c|}{} & \\
    \cline{2-6}
    &\multicolumn{5}{|c|}{} \vspace*{-0.05in}\\
    &\multicolumn{5}{|c|}{\mathsf{nand}}  \\
    &\multicolumn{5}{|c|}{}\\
    \cline{2-6}
    \vspace*{-0.03in}
    &&& | && \vspace*{-0.03in}\\
    &&&\hspace*{0.11in} |Y && \\
\end{array}  \]

The way you \emph{use} a component is
\[
  \mathit{name}(\mathit{input}_1,\ldots \mathit{input}_n)
\]
e.g., \texttt{nand(X,X)}.

A component declaration names the component and
explains what \emph{types} of signals we expect
on each of the input and output wires.
Left of the \texttt{->} arrow, we give the name and
input types, made to look like part of a grammar.
There are
different types of signals in Syrup, just as in real life
we use different types of plugs and sockets for your headphones
and for mains electricity. The simplest type of signal is
\[
  \texttt{<Bit>}
\]
When we write \texttt{not(<Bit>) ->}\ldots
We are saying `$\texttt{not(}e\texttt{)}$ makes notational sense,
whenever $e$ is meaningful as a bit', as well as
`\texttt{not} has one input and that input is a bit signal'.
Right of the \texttt{->} arrow, we say what signals come \emph{out}
of the component. In this case, we also expect a bit.

The declaration tells us nothing about what is \emph{inside} the
component, but already it tells us how we would plug things together
with it.

It is the \emph{definition} which tells us how the component computes
its output from its input. A definition is a system of equations.
\[
  \mathit{head}\;\texttt{where}\; \mathit{body}_1\;\ldots \mathit{body}_n
\]
The `head' equation deals with the external connectivity of the
component. Its left hand side, $\texttt{not(X)}$, stands for any use
of the component, and it names the input, $\texttt{X}$, corresponding
to the wire labelled $X$ in the diagram, for future reference. Its
right hand side, $\texttt{Y}$ indicates which signal is the output.

In general, when we write an equation in a Syrup program, its left hand
side is an act of \emph{naming}, and its right hand side makes \emph{use} of
named things.

Specifically, the input $\texttt{X}$ has been named in the head equation,
and the output $\texttt{Y}$ is being used, which means that we rely on the
`body' equations to tell us what $\texttt{Y}$ is. And that happens: we have a
body equation for each component inside the circuit, showing how it is wired.
The equation
\[
  \texttt{Y = nand(X,X)}
\]
tells us what that $\texttt{Y}$ is, namely the output from a $\texttt{nand}$
gate, whose inputs are both connected to $\texttt{X}$, the input of the
circuit.

So, every \emph{wire} in the diagram ($X$, $Y$) corresponds to a \emph{variable}
in the program ($\texttt{X}$, $\texttt{Y}$), and every \emph{component} in the
diagram (the $\mathsf{not}$ we are building and the $\mathsf{nand}$ we are
using) corresponds to a \emph{function} in the program ($\texttt{not}$, $\texttt{nand}$).
The equations in the program tell us how the components are wired up.

It may seem strange to bring things into existence by telling stories about them
that we hope are true, but that is in the nature of existence.


\section{Syntax}

\newcommand{\Bit}{\texttt{<Bit>}}
\newcommand{\cab}[1]{\texttt{[}#1\texttt{]}}
\newcommand{\pa}[1]{\texttt{(}#1\texttt{)}}
\newcommand{\NT}[1]{\langle\mathit{#1}\rangle}

Syrup is a formal notation with rules that must be followed if the machine is to make sense of your program.

A \emph{program} is a sequence of \emph{statements} which are written in a file or in a text area of a web browser.

\paragraph{Indentation}~ The first line of a statement must have no whitespace at the beginning: it is anchored to the left. Subsequent lines of the statement must be \emph{indented} by at least one space, to show that they are part of the same statement and not a whole new statement.

\paragraph{Statements}~ These come in three varieties:
\begin{description}
\item[declarations] introduce components by naming them and specifying their external connectivity (how many wires come in, how many come out, and what types of signals are carried on those wires) --- as it were, what's `outside the box'
\item[definitions] explain how components are constructed (the explanation consists of a system of equations which relate components and wires)
\item[experiments] request data about components in actual use
\end{description}

The declaration of a component must precede its definition. Each component should have at most one definition. A component with no definition is called a \emph{stub}. Syrup will let you build up new components from old stubs, by way of planning, but experiments involving stubs are likely to prove inconclusive.

\paragraph{Names}~ Components and wires get names. In Syrup, a valid name begins with a letter and is followed by zero or more letters or digits. Some names are not permitted because they are \emph{keywords} and have special meaning in Syrup, e.g., \texttt{where} and \texttt{experiment}.

We use names to tell things apart. Different components must have
different names: those names are \emph{global}. Within each component, the different wires must have different names. However, the names of the wires are \emph{local} to the definition of a component: they make sense within that one definition, but they are not meaningful outside the definition. In particular, you may use the same name for a wire in the definition of one component as you use in the definition of another. We will call a lot of wires $\texttt{X}$.

\paragraph{Using Components}~ The notation for using a component in a
declaration or a definition is to give its name, followed by a set of
parentheses $\texttt{( )}$ containing the component's inputs,
separated by commas. What are the inputs? In a declaration, we write
the \emph{signal types} of the inputs. On the left hand side of a
head equation, we write \emph{patterns} which give names to the
inputs. On the right hand side of an equation (head or body), we write
\emph{expressions} which explain how the inputs are to be computed.

\paragraph{Signal Types}~ The simplest signal type is \texttt{<Bit>},
the type of one-bit signals. We can build more complex signal types
by collecting signals together in \emph{cables}. A cable type is a
comma-separated list of zero or more signal types sheathed in square
brackets the way actual cables wrap bundles of wires in rubber, e.g.,
\[
  \cab{\Bit,\Bit,\Bit,\Bit}
\]
is a cable containing four one-bit signals (perhaps representing a
single hexadecimal digit). Cable types allow us to refer to a
bunch of signals tidily by a single name, thus simplifying more complex
constructions. The cable type
\[
  \cab{\Bit}
\]
is not the same thing as
\[
  \Bit
\]
in that the former has an extra layer of sheathing. Cable types
can contain smaller cable types, e.g.,
\[
  \cab{\cab{\Bit,\Bit},\cab{\Bit,\Bit}}
\]
is the type of cables which contain two cables, each of which contains
two one-bit wires. Meanwhile, the cable type
\[
  \cab{}
\]
characterizes a layer of rubber sheathing with no signal-bearing
copper inside.

\[\begin{array}{lrl}
    \NT{type} & ::= & \Bit \\
              &   | & \cab{\NT{typeList}} \medskip\\
    \NT{typeList} & ::= & \\
              &   | & \NT{types}  \medskip\\
    \NT{types} & ::= & \NT{type} \\
               &   | & \NT{type}\texttt{,}\NT{types}
\end{array} \]

\paragraph{Declarations}~ A declaration looks like
\[
  \NT{name}\pa{\NT{typeList}}\texttt{~->~}\NT{typeList}
\]
That is, we have the component name, then its input signal types
listed in parentheses, then an arrow, then the list of output
signal types.

\paragraph{Definitions}~ A definition looks like
\[
  \NT{name}\pa{\NT{patternList}}\texttt{~=~}\NT{expressionList}
    ~\texttt{where}~\NT{equations}
  \]
The \emph{patterns} explain how to analyse and name the inputs.
The expressions explain how to generate the outputs. The equations
look like
\[\begin{array}{lrl}
    \NT{equations} & ::= &  \\
              &   | & \NT{patternList}\texttt{~=~}\NT{expressionList}\;\;  \NT{equations}
\end{array}
\]
A definition may omit \texttt{where} if it has zero equations. Each
equation has patterns which name internal signals, and expressions
which explain how to compute them.

\paragraph{Patterns}~ The simplest pattern is just a variable, naming
a signal. A variable can stand for a one-bit signal or the signal
transmitted on a whole cable. However, we may also write cable
patterns, allowing us to unsheath the individual signals from inside
a cable:
\[\begin{array}{lrl}
    \NT{pattern} & ::= & \NT{name} \\
              &   | & \cab{\NT{patternList}} \medskip\\
    \NT{patternList} & ::= & \\
              &   | & \NT{patterns}  \medskip\\
    \NT{patterns} & ::= & \NT{pattern} \\
               &   | & \NT{pattern}\texttt{,}\NT{patterns}
  \end{array} \]
Within any given component, all the names in all the patterns must be
different from each other.

\paragraph{Expressions}~ The simplest expression is just a variable.
We also have uses of components, and we have cable expressions, which
sheathe a bunch of signals generated by a list of expressions.
\[\begin{array}{lrl}
    \NT{expression} & ::= & \NT{name} \\
                    &   | & \cab{\NT{expressionList}} \\
                    &   | & \NT{name}\pa{\NT{expressionList}}\medskip\\
    \NT{expressionList} & ::= & \\
              &   | & \NT{expressions}  \medskip\\
    \NT{expressions} & ::= & \NT{expression} \\
               &   | & \NT{expression}\texttt{,}\NT{expressions}
  \end{array} \]



\end{document}